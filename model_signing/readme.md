# 05.2 - Model signing

## Highlight

Let's start by familiarizing ourselves with the goal of this activity.

### What you will need

Install the [necessary software](https://github.com/slsa-framework/oss-na24-slsa-workshop/blob/main/INSTALLATION.md#model-signing).

### Model signing

The [signing library / CLI](https://github.com/sigstore/model-transparency/tree/main/model_signing) uses the sigstore signing solution which makes code signatures transparent without requiring management of cryptographic key material. You can read an [overview of Sigstore](https://github.com/sigstore/model-transparency/blob/main/model_signing/README.md#model-signing). We encourage you to check the official [sigstore.dev](https://www.sigstore.dev/) after the workshop to learn more. In this demo, you will see first hand some of the benefits of using Sigstore, i.e. you won't have to manage keys!

Sigstore has bindings for [many languages](https://gihub.com/sigstore). In this demo we use the [Python bindings](https://github.com/sigstore/sigstore-python). Shout-out to their maintainers [@woodruffw](https://github.com/woodruffw) and [@jku](https://github.com/jku) for making this demo possible!

## Deep dive

### Installation

Install [Sigstore](https://github.com/slsa-framework/oss-na24-slsa-workshop/blob/main/INSTALLATION.md#sigstore-python) and [model-transparency](https://github.com/slsa-framework/oss-na24-slsa-workshop/blob/main/INSTALLATION.md#model-transparency) tools.

### Warmup: Model verification

Download the model tarball from GitHub at [https://github.com/slsa-framework/oss-na24-slsa-workshop-model-integrity/releases/download/v0.0.1/tensorflow_saved_model.tar.gz](https://github.com/slsa-framework/oss-na24-slsa-workshop-model-integrity/releases/download/v0.0.1/tensorflow_saved_model.tar.gz). Then extract its content:

```shell
$ tar xvzf tensorflow_saved_model.tar.gz
$ model_path=$(pwd)/tensorflow_saved_model
```

Ensure you are running in the [python virtal environment](https://github.com/slsa-framework/oss-na24-slsa-workshop/blob/main/INSTALLATION.md#sigstore-python) where you installed the tooling: 

```shell
$ cd sigstore-python
$ source env/bin/activate
$ cd ..
```

Verify the model. The signer is `laurentsimon@google.com` and the identity provider is `https://accounts.google.com`.

```shell
$ provider=https://accounts.google.com
$ identity=laurentsimon@google.com
$ cd model-transparency/model_signing
$ python3 main.py verify --path "${model_path}" --identity "${identity}" --identity-provider "${provider}"
$ cd ../../
```

All you need to verify is an identity and an identity provider. No cryptographic keys involved. Let's see in details how everything fits together in the next section.

### End-to-end model signing and verification

#### Model training

Training will take up to 15mn. You can use the pre-trained model from the previous section instead if you prefer.

Follow the instuctions below:

```shell
$ git clone git@github.com:slsa-framework/oss-na24-slsa-workshop-model-integrity.git && cd oss-na24-slsa-workshop-model-integrity
# One of Linux, Windows or macOS
$ OS=Linux
$ python3 -m pip install --require-hashes -r "slsa_for_models/install/requirements_${OS}.txt"
# Start the training
# WARNING: This may take up to 15mn.
$ python3 slsa_for_models/main.py tensorflow_saved_model
$ model_path=$(pwd)/tensorflow_saved_model
$ cd ..
```

The model is stored under directory `tensorflow_saved_model`.

#### Model signing

```shell
$ cd model-transparency/model_signing
$ python3 main.py sign --path "${model_path}"
Go to the following link in a browser:

	https://oauth2.sigstore.dev/auth/auth?response_type=code....

Enter verification code:
```

You shoud be prompted with a verification code. If you do not, re-run the same command but additionally pass the `--disable-ambient` flag.

What is the verification code? Sigstore is asking you to authenticate to your email provider via [OIDC Connect](https://openid.net/developers/how-connect-works/). At the time of writing, Sigstore supports [three identity providers](https://github.com/sigstore/model-transparency/blob/main/model_signing/README.md): Google, Microsoft and GitHub. Copy the weblink that is presented to you in your web browser and follow the steps. You'll get a token. Copy it in the terminal and press Enter.

```shell
Enter verification code: .....
```

Sigstore used the token you provided and issued an x509 certificate for your identity. The signing key is generated by the client and is _never_ seen by Sigstore. Sigstore only knows the public key part, and it puts it in the x509 certificate. Each time the client signs, it creates a new signing key pair and then throws it away. No need to worry about keeping the private key secure. There are a lot more details we are glossing over, like the transparency log [Rekor](https://docs.sigstore.dev/logging/overview/). Take a look at the [documentation](https://sigstoe.dev) and ask question on [slack](https://www.sigstore.dev/community)!


### Model verification

To verify, you need to know both the identity of the signer and its identity provider:

- Google's provider is `https://accounts.google.com`.
- GitHub's provider is `https://github.com/login/oauth`.
- Microsoft's provider is `https://login.microsoftonline.com`.

```shell
$ provider=_one_of_providers_above
$ identity=email@provider.com
$ python3 main.py verify --path "${model_path}" --identity "${identity}" --identity-provider "${provider}"
```

Try editing, deleting or adding files to your model and re-run the verification.

#### Signature bundle

The signature file is in a format called a [Sigstore bundle](https://github.com/sigstore/protobuf-specs/blob/7f7548165de89a5cf7c4ec2f3728c5e3763e4d96/protos/sigstore_bundle.proto#L111). It is a flexible signature format that can accommodate x509 certificates (public or private PKI), static keys, [TUF keys](https://theupdateframework.io/), etc.

Let's take a look at the signature file. Make sure [jq](https://github.com/slsa-framework/oss-na24-slsa-workshop/blob/main/INSTALLATION.md#jq) and [openssl](https://github.com/slsa-framework/oss-na24-slsa-workshop/blob/main/INSTALLATION.md#openssl) are installed on your machine.

```shell
$ jq < "${model_path}/model.sig"
# Visualize the certificate Sigstore created for your identity
$ jq -r '.verificationMaterial.certificate.rawBytes'< "${model_path}/model.sig" | base64 -d | openssl x509 -text -noout
[...]
X509v3 Subject Alternative Name: critical
    email:laurentsimon@google.com
1.3.6.1.4.1.57264.1.1: 
    https://accounts.google.com
1.3.6.1.4.1.57264.1.8: 
    ..https://accounts.google.com
```

The identity and identity providers will look different for you.

Now let's see the actual data that was signed:

```shell
$ jq -r '.dsseEnvelope.payload' <"${model_path}/model.sig" | base64 -d | jq
[...]
"files": [
    {
        "path": "fingerprint.pb",
        "digest": {
            "sha256-p1": "6c6b3dab5e529ac434f5640dc0c2593eff1569a2b87238cd7fc35181f42b1cbf"
        }
    },
    {
        "path": "saved_model.pb",
        "digest": {
            "sha256-p1": "ea9e0870b9a6911a3e2066cd91b7ea467c2c26248ee171c2f6c7c32f7c13c7fd"
        }
    },
    {
        "path": "variables/variables.data-00000-of-00001",
        "digest": {
            "sha256-p1": "f4058fefc1932d7e6480087fb357b38dc935084494d81afeb50b02a54a80938b"
        }
    },
    {
        "path": "variables/variables.index",
        "digest": {
            "sha256-p1": "35a26c0124980180d0bd40cb883bce58b06d421ec1ed49be634d9a37bafbab6e"
        }
    }
]

```

You see a list of files present in the model, each with their corresponding path and digest. Notice the digest is of type `sha256-p1`. Model files can be several hundreds of gigabytes in size. So to speed up hash computation, each file is split into multiple chunks that are hashed separately. `p` stands for "parallel", because multiple hashing routines work in parallel to compute a file digest.

### Future work

#### Sign on publication

Try signinng your models before uploading them to your favorite hub, [Huggingface](https://huggingface.co/), [Tensorflow hub](https://www.tensorflow.org/hub), [PyTorch hub](https://pytorch.org/hub/), etc.

#### Support workoad identities

Signing with Sigstore not only supports human identity (email addresses), but also workflow identity. For automated signing using a workload identity, the following platforms are currently supported, shown with their expected identities:

- GitHub Actions (`https://github.com/octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main`)
- GitLab CI (`https://gitlab.com/my-group/my-project//path/to/.gitlab-ci.yml@refs/heads/main`)
- Google Cloud Platform (`SERVICE_ACCOUNT_NAME@PROJECT_ID.iam.gserviceaccount.com`)
Buildkite CI (`https://buildkite.com/ORGANIZATION_SLUG/PIPELINE_SLUG`)

Try that out and let us know how it goes!

#### Sign other data

You can use the same CLI / API to sign datasets, checkpoints, etc.

## Take the quizz!

After completing this activity, you should be able to answer the following questions:

1. What is Sigstore? What are its advantages for individuals? 
2. What format are signature files?
3. What data is present in the signature?
4. Why is hasing of models slow? What does this demo do to speed up hashing?
