# 05.1 - Model signing

## Highlight

Let's start by familiarizing ourselves with the goal of this activity.

### What you will need

Install the [necessary software](https://github.com/slsa-framework/oss-na24-slsa-workshop/blob/main/INSTALLATION.md#model-signing).

### Model signing

The [signing library / CLI](https://github.com/sigstore/model-transparency/tree/main/model_signing) uses the sigstore signing solution which makes code signatures transparent without requiring management of cryptographic key material. You can read an [overview of Sigstore](https://github.com/sigstore/model-transparency/blob/main/model_signing/README.md#model-signing). We encourage you to check the official [sigstore.dev](https://www.sigstore.dev/) after the workshop to learn more. In this demo, you will see first hand some of the benefits of using Sigstore, i.e. you won't have to manage keys!

Sigstore has bindings for [many languages](https://gihub.com/sigstore). In this demo we use the [Python bindings](https://github.com/sigstore/sigstore-python). Shout-out to their maintainers [@woodruffw](https://github.com/woodruffw) and [@jku](https://github.com/jku) for making this demo possible!

## Deep dive

### Installation

Install [Sigstore](https://github.com/slsa-framework/oss-na24-slsa-workshop/blob/main/INSTALLATION.md#sigstore-python) and [model-transparency](https://github.com/slsa-framework/oss-na24-slsa-workshop/blob/main/INSTALLATION.md#model-transparency) tools.

### Warmup: Model verification

TODO: download from GH

Ensure you are running in the [python virtal environment](https://github.com/slsa-framework/oss-na24-slsa-workshop/blob/main/INSTALLATION.md#sigstore-python) where you installed the tooling: 

```shell
$ cd sigstore-python
$ source env/bin/activate
$ cd ..
```

Verify the model. The signer is `laurentsimon@google.com` and the identity provider is `https://accounts.google.com`.

```shell
$ provider=https://accounts.google.com
$ identity=laurentsimon@google.com
$ cd model-transparency/model_signing
$ python3 main.py verify --path path/to/model/ --identity "${identity}" --identity-provider "${provider}"
```

All you needed to verify was an identity and its provider. No cryptographic keys involved. Let's see in details how everything fits together in the next section.

### End-to-end model signing and verification

#### Mode training
TODO: download ready-made or instruction to run it.

This will take 10mn or so. You can download a pre-trained model if you prefer.

#### Model signing

Ensure you are running in the [python virtal environment](https://github.com/slsa-framework/oss-na24-slsa-workshop/blob/main/INSTALLATION.md#sigstore-python) where you installed the tooling: 

```shell
$ cd sigstore-python
$ source env/bin/activate
$ cd ..
```

```shell
$ cd model-transparency/model_signing
$ model=path/to/model/
$ python3 main.py sign --path "${model}"
Go to the following link in a browser:

	https://oauth2.sigstore.dev/auth/auth?response_type=code....

Enter verification code:
```

What just happened? What is this link? Sigstore is asking you to authenticate to you email provider via [OIDC Connect](https://openid.net/developers/how-connect-works/). At the time of writing, Sigstore supports [three identity providers](https://github.com/sigstore/model-transparency/blob/main/model_signing/README.md): Google, Microsoft and GitHub. Copy the weblink that is presented to you in your web browser and follow the steps. You'll get a token. Copy it in the terminal and press Enter.

```shell
Enter verification code: .....
identity: your-email@provider.com
```

Sigstore used the token you provided and issued an x509 certificate for your identity. The signing key is generated by the client and is _never_ seen by Sigstore. Sigstore only knows the public key part, and it puts it in the x509 certificate. Each time the client signs, it creates a new signing key pair and then throws it away. No need to worry about keeping the private key secure. There are a lot more details we are glossing over, like the transparency log [Rekor](https://docs.sigstore.dev/logging/overview/). Take a look at the [documentation](https://sigstoe.dev) and ask question on [slack](https://www.sigstore.dev/community)!


### Model verification

To verify, you need to know both the identity of the signer and its identity provider:

- Google's provider is `https://accounts.google.com`.
- GitHub's provider is `https://github.com/login/oauth`.
- Microsoft's provider is `https://login.microsoftonline.com`.

```shell
$ provider=_one_of_providers_above
$ identity=email@provider.com
$ model=path/to/model/
$ python3 main.py verify --path "${model}" --identity "${identity}" --identity-provider "${provider}"
```

Try editing, deleting or adding files to your model and re-run the verification.

#### Signature bundle

The signature file is in a format called a [Sigstore bundle](https://github.com/sigstore/protobuf-specs/blob/7f7548165de89a5cf7c4ec2f3728c5e3763e4d96/protos/sigstore_bundle.proto#L111). It is a flexible signature format that can accommodate x509 certificates (public or private PKI), static keys, [TUF keys](https://theupdateframework.io/), etc.

Let's take a look at the signature file. Make sure [jq](https://github.com/slsa-framework/oss-na24-slsa-workshop/blob/main/INSTALLATION.md#jq) and [openssl](https://github.com/slsa-framework/oss-na24-slsa-workshop/blob/main/INSTALLATION.md#openssl) are installed on your machine.

```shell
$ model=path/to/model/
$ jq < "${model}model.sig"
# Visualize the certificate Sigstore created for your identity
$ jq -r '.verificationMaterial.certificate.rawBytes'< "${model}"model.sig | base64 -d | openssl x509 -text -noout
[...]
X509v3 Subject Alternative Name: critical
    email:laurentsimon@google.com
1.3.6.1.4.1.57264.1.1: 
    https://accounts.google.com
1.3.6.1.4.1.57264.1.8: 
    ..https://accounts.google.com
```

The identity and identity providers will look different for you.

Now let's see the actual data that was signed:

```shell
$ model=path/to/model/
$ jq -r '.dsseEnvelope.payload' <"${model}"model.sig | base64 -d | jq
[...]
"files": [
    {
        "path": "file1",
        "digest": {
            "sha256-p1": "219f53a60f342f50dbe0d826c11daa01d55fded4b508c7559952fdae38c0e835"
        }
    },
    {
        "path": "file2",
        "digest": {
            "sha256-p1": "7c006a42fcd3bfff91e279da0f467ecc7ba07027a8f208e9f5671f5e844bfd2c"
        }
    }
    [...]
]
```

You see a list of files present in the model, each with their path and digest. Notice the digest is of type `sha256-p1`. Model files can be several hundreds of gigabytes in size. So to speed up hash computation, each file is split into multiple chunks that are hashes separately. `p` stands for parallel, because multiple hashing routine work in parallel to compute a file digest.

### Future work

#### Support other protection types

Signing with Sigstore not only supports human identity (email addresses), but also workflow identity. For automated signing using a workload identity, the following platforms are currently supported, shown with their expected identities:

- GitHub Actions (`https://github.com/octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main`)
- GitLab CI (`https://gitlab.com/my-group/my-project//path/to/.gitlab-ci.yml@refs/heads/main`)
- Google Cloud Platform (`SERVICE_ACCOUNT_NAME@PROJECT_ID.iam.gserviceaccount.com`)
Buildkite CI (`https://buildkite.com/ORGANIZATION_SLUG/PIPELINE_SLUG`)

Try that out and let us know how it goes!

## Take the quizz!

After completing this activity, you should be able to answer the following questions:

1. What is Sigstore? What are its advantages for individuals? 
2. What format are signature files?
3. What data is present in the signature?
4. Why is hasing of models slow? What does this demo do to speed up hashing?
